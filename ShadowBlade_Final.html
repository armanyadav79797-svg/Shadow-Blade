<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Shadow Blade Master</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: 'Bebas Neue', Arial, sans-serif;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-3px, 3px); }
            75% { transform: translate(3px, -3px); }
        }
        
        .shake {
            animation: shake 0.1s ease-in-out;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }
        
        #score {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #ff0000;
            font-size: 42px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 3px 3px 6px #000;
            letter-spacing: 3px;
            transition: transform 0.1s ease;
        }
        
        #score.pop {
            animation: scorePop 0.3s ease-out;
        }
        
        @keyframes scorePop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        
        #multiplier {
            position: absolute;
            top: 90px;
            left: 30px;
            color: #ffd700;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffd700, 2px 2px 4px #000;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #multiplier.show {
            opacity: 1;
        }
        
        #timer {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 2px 2px 4px #000;
            letter-spacing: 2px;
        }
        
        #health {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
        }
        
        .life-icon {
            width: 50px;
            height: 50px;
            font-size: 40px;
            filter: drop-shadow(0 0 10px #ff0000);
            animation: float 2s ease-in-out infinite;
        }
        
        .life-icon.lost {
            opacity: 0.2;
            filter: grayscale(100%);
            animation: none;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        
        #comboDisplay {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 92px;
            font-weight: bold;
            text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700, 0 0 60px #ffd700, 4px 4px 8px #000;
            pointer-events: none;
            opacity: 0;
            letter-spacing: 4px;
        }
        
        #comboDisplay.show {
            animation: comboSlide 0.8s ease-out;
        }
        
        @keyframes comboSlide {
            0% { opacity: 0; transform: translate(-50%, -80%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        
        #perfectHit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 72px;
            font-weight: bold;
            text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
            pointer-events: none;
            opacity: 0;
            letter-spacing: 4px;
        }
        
        #perfectHit.show {
            animation: perfectPop 0.6s ease-out;
        }
        
        @keyframes perfectPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        
        #slowMoIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff00ff;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff00ff;
            pointer-events: none;
            opacity: 0;
        }
        
        #slowMoIndicator.active {
            opacity: 1;
            animation: pulse 0.5s ease-in-out infinite;
        }
        
        #riskBonus {
            position: absolute;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            color: #ffaa00;
            font-size: 42px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffaa00, 3px 3px 6px #000;
            pointer-events: none;
            opacity: 0;
            letter-spacing: 3px;
        }
        
        #riskBonus.show {
            animation: riskPop 1s ease-out;
        }
        
        @keyframes riskPop {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            50% { opacity: 1; transform: translateX(-50%) translateY(0px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
        }
        
        #gameOver, #startScreen, #upgradeScreen, #dailyChallenge {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #gameOver.show, #startScreen.show, #upgradeScreen.show, #dailyChallenge.show {
            display: flex;
        }
        
        .title {
            color: #ff0000;
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            animation: titleGlow 3s ease-in-out infinite;
            letter-spacing: 8px;
        }
        
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
            50% { text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000; }
        }
        
        .subtitle {
            color: #ffd700;
            font-size: 36px;
            margin-bottom: 40px;
            text-shadow: 0 0 15px #ffd700;
            letter-spacing: 3px;
        }
        
        .stat {
            color: #fff;
            font-size: 32px;
            margin: 10px 0;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
        }
        
        .stat span {
            color: #ffd700;
        }
        
        .btn {
            padding: 20px 60px;
            font-size: 38px;
            font-weight: bold;
            font-family: 'Bebas Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: #fff;
            border: 4px solid #ffd700;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 30px #ff0000, 0 8px 20px rgba(0, 0, 0, 0.7);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin: 10px;
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .btn.secondary {
            background: linear-gradient(135deg, #333 0%, #111 100%);
            box-shadow: 0 0 15px #666, 0 8px 20px rgba(0, 0, 0, 0.7);
        }
        
        .mode-btn {
            padding: 25px 80px;
            font-size: 42px;
            font-weight: bold;
            font-family: 'Bebas Neue', Arial, sans-serif;
            color: #fff;
            border: 4px solid #ffd700;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5), 0 8px 20px rgba(0, 0, 0, 0.7);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin: 10px;
        }
        
        .mode-btn.easy { background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%); }
        .mode-btn.normal { background: linear-gradient(135deg, #ffaa00 0%, #cc8800 100%); }
        .mode-btn.hardcore { 
            background: linear-gradient(135deg, #ff0000 0%, #990000 100%);
            animation: hardcoreGlow 2s ease-in-out infinite;
        }
        
        @keyframes hardcoreGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.5), 0 8px 20px rgba(0, 0, 0, 0.7); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 0, 1), 0 8px 20px rgba(0, 0, 0, 0.7); }
        }
        
        .mode-btn:active { transform: scale(0.95); }
        
        .mode-desc {
            display: block;
            font-size: 20px;
            margin-top: 5px;
            opacity: 0.9;
        }
        
        #bladeSelection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
            max-width: 90%;
        }
        
        .blade-card {
            background: rgba(20, 20, 40, 0.9);
            border: 3px solid #444;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .blade-card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 20px #ffd700;
            transform: scale(1.05);
        }
        
        .blade-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .blade-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .blade-name {
            color: #fff;
            font-size: 24px;
            margin-bottom: 5px;
            letter-spacing: 2px;
        }
        
        .blade-requirement {
            color: #aaa;
            font-size: 16px;
            letter-spacing: 1px;
        }
        
        .blade-card.unlocked .blade-requirement {
            color: #00ff00;
        }
        
        #achievementPopup {
            position: absolute;
            top: 120px;
            right: 30px;
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            border: 3px solid #ffd700;
            border-radius: 10px;
            padding: 20px 30px;
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 30px #ff0000;
            pointer-events: none;
            transform: translateX(500px);
            transition: transform 0.5s ease;
        }
        
        #achievementPopup.show {
            transform: translateX(0);
        }
        
        #muteBtn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ffd700;
            border-radius: 50%;
            color: #ffd700;
            font-size: 32px;
            cursor: pointer;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        #muteBtn:active {
            transform: scale(0.9);
        }
        
        .instructions {
            position: absolute;
            bottom: 60px;
            color: #ccc;
            font-size: 24px;
            text-align: center;
            padding: 0 20px;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
        }
        
        #dailyChallengeBtn {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 28px;
            font-weight: bold;
            font-family: 'Bebas Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #ff00ff 0%, #cc00cc 100%);
            color: #fff;
            border: 3px solid #ffd700;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px #ff00ff;
            letter-spacing: 3px;
            pointer-events: all;
        }
        
        #warningZone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 5px solid rgba(255, 0, 0, 0);
            border-radius: 50%;
            pointer-events: none;
            transition: border-color 0.3s ease;
        }
        
        #warningZone.danger {
            border-color: rgba(255, 0, 0, 0.8);
            animation: dangerPulse 0.5s ease-in-out infinite;
        }
        
        @keyframes dangerPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen" class="show">
        <div class="title">SHADOW BLADE</div>
        <div class="subtitle">"Strike Like Thunder, Vanish Like Wind"</div>
        <div style="display: flex; flex-direction: column; gap: 20px;">
            <button class="mode-btn easy" data-mode="easy">
                EASY
                <span class="mode-desc">Calm Before The Storm</span>
            </button>
            <button class="mode-btn normal" data-mode="normal">
                NORMAL
                <span class="mode-desc">The Way of the Warrior</span>
            </button>
            <button class="mode-btn hardcore" data-mode="hardcore">
                HARDCORE
                <span class="mode-desc">Death's Doorstep</span>
            </button>
        </div>
        <button class="btn secondary" id="bladesBtn" style="margin-top: 30px;">‚öîÔ∏è BLADES</button>
        <div class="instructions">‚öîÔ∏è Swipe to deflect knives ‚Ä¢ Combos = Bonuses ‚öîÔ∏è</div>
    </div>
    
    <div id="upgradeScreen">
        <div class="title">BLADE COLLECTION</div>
        <div class="subtitle">Unlock by achieving goals</div>
        <div id="bladeSelection"></div>
        <button class="btn" id="backBtn">BACK</button>
    </div>
    
    <div id="dailyChallenge">
        <div class="title">DAILY CHALLENGE</div>
        <div class="subtitle" id="challengeDesc">Survive 120 seconds</div>
        <div class="stat">Reward: <span>Fire Blade</span></div>
        <div class="stat" id="challengeProgress">Progress: <span>0 / 120s</span></div>
        <button class="btn" id="startChallengeBtn">START</button>
        <button class="btn secondary" id="closeChallengeBtn">CLOSE</button>
    </div>
    
    <div id="ui">
        <div id="score">0</div>
        <div id="multiplier">x1.0</div>
        <div id="timer">0:00</div>
        <button id="dailyChallengeBtn">üèÜ DAILY</button>
        <div id="health">
            <div class="life-icon">üî•</div>
            <div class="life-icon">üî•</div>
            <div class="life-icon">üî•</div>
        </div>
        <div id="comboDisplay"></div>
        <div id="perfectHit">PERFECT!</div>
        <div id="slowMoIndicator">‚ö° SLOW MOTION ‚ö°</div>
        <div id="riskBonus">RISK BONUS!</div>
        <div id="warningZone"></div>
        <button id="muteBtn">üîä</button>
    </div>
    
    <div id="gameOver">
        <div class="title">DEFEATED</div>
        <div class="subtitle">The Shadow Falls</div>
        <div class="stat">Score: <span id="finalScore">0</span></div>
        <div class="stat">Best: <span id="highScore">0</span></div>
        <div class="stat">Max Combo: <span id="maxCombo">0</span></div>
        <div class="stat">Perfect Hits: <span id="perfectHits">0</span></div>
        <div class="stat" id="newUnlock" style="color: #00ff00; display: none;">üéâ NEW BLADE UNLOCKED! üéâ</div>
        <button class="btn" id="restartBtn">RETRY</button>
        <button class="btn secondary" id="menuBtn">MENU</button>
    </div>
    
    <div id="achievementPopup"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Audio System
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let isMuted = false;
        
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (isMuted) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playSlashSound() {
            playSound(800, 0.1, 'sawtooth', 0.2);
            setTimeout(() => playSound(400, 0.05, 'square', 0.15), 30);
        }
        
        function playHitSound() {
            playSound(1200, 0.15, 'square', 0.3);
            setTimeout(() => playSound(800, 0.1, 'triangle', 0.2), 40);
        }
        
        function playPerfectSound() {
            playSound(1500, 0.1, 'sine', 0.25);
            setTimeout(() => playSound(2000, 0.15, 'sine', 0.3), 50);
            setTimeout(() => playSound(2500, 0.2, 'sine', 0.25), 120);
        }
        
        function playComboSound() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => playSound(1000 + i * 300, 0.1, 'triangle', 0.2), i * 50);
            }
        }
        
        function playMissSound() {
            playSound(200, 0.3, 'sawtooth', 0.4);
        }
        
        function playLoseLifeSound() {
            playSound(100, 0.5, 'sawtooth', 0.5);
            setTimeout(() => playSound(80, 0.3, 'square', 0.4), 200);
        }

        // Blade Types
        const blades = {
            classic: { 
                name: 'Classic', 
                color: '#00ffff', 
                icon: '‚öîÔ∏è', 
                unlocked: true, 
                requirement: 'Default',
                effect: 'standard'
            },
            fire: { 
                name: 'Fire', 
                color: '#ff4400', 
                icon: 'üî•', 
                unlocked: false, 
                requirement: '50 Perfect Hits',
                requiredPerfect: 50,
                effect: 'fire'
            },
            lightning: { 
                name: 'Lightning', 
                color: '#ffff00', 
                icon: '‚ö°', 
                unlocked: false, 
                requirement: '100 Combo',
                requiredCombo: 100,
                effect: 'lightning'
            },
            ice: { 
                name: 'Ice', 
                color: '#00ffff', 
                icon: '‚ùÑÔ∏è', 
                unlocked: false, 
                requirement: 'Score 1000',
                requiredScore: 1000,
                effect: 'ice'
            },
            shadow: { 
                name: 'Shadow', 
                color: '#9900ff', 
                icon: 'üåô', 
                unlocked: false, 
                requirement: '30 Second Survival',
                requiredTime: 30,
                effect: 'shadow'
            },
            blood: { 
                name: 'Blood', 
                color: '#cc0000', 
                icon: 'üíÄ', 
                unlocked: false, 
                requirement: 'Hardcore Mode Win',
                requiredHardcore: true,
                effect: 'blood'
            }
        };
        
        let currentBlade = 'classic';
        
        // Load saved data
        Object.keys(blades).forEach(key => {
            const saved = localStorage.getItem(`blade_${key}`);
            if (saved === 'true') blades[key].unlocked = true;
        });
        
        const savedBlade = localStorage.getItem('selectedBlade');
        if (savedBlade && blades[savedBlade]?.unlocked) {
            currentBlade = savedBlade;
        }

        // Game State
        let gameState = {
            score: 0,
            highScore: {},
            health: 3,
            isGameOver: false,
            gameStarted: false,
            difficulty: 'normal',
            knifeSpeed: 3.5,
            knifeSpawnRate: 1000,
            lastSpawn: 0,
            difficultyTimer: 0,
            combo: 0,
            comboTimer: 0,
            maxCombo: 0,
            perfectHits: 0,
            totalPerfectHits: parseInt(localStorage.getItem('totalPerfectHits')) || 0,
            timeScale: 1,
            slowMoTimer: 0,
            riskMultiplier: 1,
            closeCallTimer: 0,
            survivalTime: 0,
            maxScore: parseInt(localStorage.getItem('maxScore')) || 0,
            maxComboEver: parseInt(localStorage.getItem('maxCombo')) || 0,
            hardcoreWins: parseInt(localStorage.getItem('hardcoreWins')) || 0,
            maxSurvivalTime: parseInt(localStorage.getItem('maxSurvivalTime')) || 0,
            challengeMode: false,
            challengeTime: 0,
            achievementsShown: new Set()
        };
        
        ['easy', 'normal', 'hardcore'].forEach(mode => {
            gameState.highScore[mode] = localStorage.getItem(`hs_${mode}`) || 0;
        });

        // Difficulty settings
        const difficultySettings = {
            easy: { name: 'EASY', knifeSpeed: 2, spawnRate: 1500, speedIncrease: 0.15, spawnDecrease: 120 },
            normal: { name: 'NORMAL', knifeSpeed: 3.5, spawnRate: 1000, speedIncrease: 0.3, spawnDecrease: 100 },
            hardcore: { name: 'HARDCORE', knifeSpeed: 5, spawnRate: 700, speedIncrease: 0.5, spawnDecrease: 80 }
        };

        // Background
        const mountains = [];
        const clouds = [];
        const sakuraPetals = [];
        
        function initBackground() {
            mountains.push({
                points: generateMountain(0, canvas.height * 0.6, canvas.width),
                color: 'rgba(20, 20, 40, 0.9)'
            });
            mountains.push({
                points: generateMountain(0, canvas.height * 0.65, canvas.width),
                color: 'rgba(30, 30, 50, 0.8)'
            });
            mountains.push({
                points: generateMountain(0, canvas.height * 0.7, canvas.width),
                color: 'rgba(40, 40, 60, 0.6)'
            });
            
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.4,
                    width: Math.random() * 100 + 80,
                    speed: Math.random() * 0.3 + 0.1
                });
            }
            
            for (let i = 0; i < 30; i++) {
                sakuraPetals.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 4 + 2,
                    speed: Math.random() * 0.5 + 0.3,
                    swing: Math.random() * Math.PI * 2,
                    swingSpeed: Math.random() * 0.02 + 0.01
                });
            }
        }
        
        function generateMountain(startX, startY, width) {
            const points = [{x: startX, y: canvas.height}];
            const peaks = 4;
            const segmentWidth = width / peaks;
            
            for (let i = 0; i < peaks; i++) {
                const peakX = startX + segmentWidth * (i + 0.5);
                const peakY = startY - Math.random() * 100 - 50;
                points.push({x: peakX, y: peakY});
            }
            
            points.push({x: startX + width, y: canvas.height});
            return points;
        }
        
        function drawBackground() {
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#1a0a2e');
            skyGradient.addColorStop(0.4, '#2d1b3d');
            skyGradient.addColorStop(0.7, '#4a2545');
            skyGradient.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gradient = ctx.createRadialGradient(canvas.width * 0.2, canvas.height * 0.25, 10, canvas.width * 0.2, canvas.height * 0.25, 80);
            gradient.addColorStop(0, 'rgba(255, 200, 150, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 150, 100, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.2, canvas.height * 0.25, 80, 0, Math.PI * 2);
            ctx.fill();
            
            mountains.forEach(mountain => {
                ctx.fillStyle = mountain.color;
                ctx.beginPath();
                ctx.moveTo(mountain.points[0].x, mountain.points[0].y);
                mountain.points.forEach(point => ctx.lineTo(point.x, point.y));
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                for (let i = 1; i < mountain.points.length - 1; i++) {
                    const point = mountain.points[i];
                    ctx.beginPath();
                    ctx.moveTo(point.x - 20, point.y + 30);
                    ctx.lineTo(point.x, point.y);
                    ctx.lineTo(point.x + 20, point.y + 30);
                    ctx.closePath();
                    ctx.fill();
                }
            });
            
            clouds.forEach(cloud => {
                ctx.fillStyle = 'rgba(100, 100, 120, 0.3)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width, 30, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.fillStyle = 'rgba(10, 10, 20, 0.8)';
            const templeX = canvas.width * 0.75;
            const templeY = canvas.height * 0.65;
            ctx.beginPath();
            ctx.moveTo(templeX - 80, templeY);
            ctx.lineTo(templeX, templeY - 40);
            ctx.lineTo(templeX + 80, templeY);
            ctx.closePath();
            ctx.fill();
            ctx.fillRect(templeX - 50, templeY, 100, 60);
            
            sakuraPetals.forEach(petal => {
                ctx.fillStyle = 'rgba(255, 182, 193, 0.7)';
                ctx.save();
                ctx.translate(petal.x, petal.y);
                ctx.rotate(petal.swing);
                ctx.beginPath();
                ctx.ellipse(0, 0, petal.size, petal.size * 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
        
        function updateBackground(deltaTime) {
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + 100) cloud.x = -100;
            });
            
            sakuraPetals.forEach(petal => {
                petal.y += petal.speed;
                petal.x += Math.sin(petal.swing) * 0.5;
                petal.swing += petal.swingSpeed;
                
                if (petal.y > canvas.height) {
                    petal.y = -10;
                    petal.x = Math.random() * canvas.width;
                }
            });
        }

        // Particles
        const particles = [];
        
        class Particle {
            constructor(x, y, color, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * (type === 'blood' ? 4 : 8);
                this.vy = (Math.random() - 0.5) * (type === 'blood' ? 4 : 8);
                this.radius = Math.random() * (type === 'blood' ? 3 : 4) + (type === 'blood' ? 1 : 2);
                this.color = color;
                this.alpha = 1;
                this.decay = Math.random() * 0.03 + 0.02;
                this.type = type;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.type === 'blood' ? 0.3 : 0.2;
                this.alpha -= this.decay;
                this.radius *= 0.97;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 45,
            pulsePhase: 0,
            flashTimer: 0,
            isFlashing: false,
            rotation: 0,
            breathePhase: 0
        };

        const knives = [];
        const bladeTrails = [];

        let isDrawing = false;
        let currentTrail = null;

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);

        function handleStart(e) {
            e.preventDefault();
            if (gameState.isGameOver || !gameState.gameStarted) return;
            
            isDrawing = true;
            const pos = getInputPosition(e);
            currentTrail = {
                points: [pos],
                alpha: 1,
                lifetime: 0
            };
            bladeTrails.push(currentTrail);
            playSlashSound();
        }

        function handleMove(e) {
            e.preventDefault();
            if (!isDrawing || gameState.isGameOver || !gameState.gameStarted) return;
            
            const pos = getInputPosition(e);
            if (currentTrail && currentTrail.points.length > 0) {
                const lastPoint = currentTrail.points[currentTrail.points.length - 1];
                const dist = Math.hypot(pos.x - lastPoint.x, pos.y - lastPoint.y);
                if (dist > 5) {
                    currentTrail.points.push(pos);
                    
                    if (Math.random() > 0.5) {
                        particles.push(new Particle(pos.x, pos.y, blades[currentBlade].color, 'spark'));
                    }
                }
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            isDrawing = false;
            currentTrail = null;
        }

        function getInputPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            return { x, y };
        }

        function spawnKnife() {
            const edge = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(edge) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                case 2: x = -50; y = Math.random() * canvas.height; break;
                case 3: x = canvas.width + 50; y = Math.random() * canvas.height; break;
            }
            
            const angle = Math.atan2(player.y - y, player.x - x);
            
            // Occasionally spawn fake traps (after 30 seconds)
            const isFake = gameState.survivalTime > 30 && Math.random() < 0.1;
            
            knives.push({
                x, y,
                vx: Math.cos(angle) * gameState.knifeSpeed,
                vy: Math.sin(angle) * gameState.knifeSpeed,
                angle: angle,
                rotation: 0,
                length: isFake ? 30 : 40,
                width: isFake ? 6 : 10,
                isFake: isFake,
                spawnTime: performance.now()
            });
        }

        function drawNinja(x, y, radius, rotation, breathe) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            const scale = 1 + Math.sin(breathe) * 0.03;
            ctx.scale(scale, scale);
            
            const shadowGradient = ctx.createRadialGradient(0, 0, radius * 0.5, 0, 0, radius * 2);
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            if (!player.isFlashing) {
                const auraGradient = ctx.createRadialGradient(0, 0, radius * 0.8, 0, 0, radius * 1.8);
                auraGradient.addColorStop(0, `rgba(0, 255, 255, 0)`);
                auraGradient.addColorStop(0.5, `rgba(0, 255, 255, 0.2)`);
                auraGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.8, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.fillStyle = player.isFlashing ? '#660000' : '#0a0a1a';
            ctx.strokeStyle = player.isFlashing ? '#ff0000' : '#1a1a2e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = player.isFlashing ? '#ff0000' : '#2a2a4e';
            ctx.beginPath();
            ctx.arc(-radius * 0.6, -radius * 0.4, radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(radius * 0.6, -radius * 0.4, radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = player.isFlashing ? '#440000' : '#050510';
            ctx.beginPath();
            ctx.ellipse(0, -radius * 0.2, radius * 0.7, radius * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const eyeColor = player.isFlashing ? '#ff0000' : '#00ffff';
            ctx.shadowBlur = 15;
            ctx.shadowColor = eyeColor;
            ctx.fillStyle = eyeColor;
            ctx.fillRect(-radius * 0.35, -radius * 0.25, radius * 0.25, 5);
            ctx.fillRect(radius * 0.1, -radius * 0.25, radius * 0.25, 5);
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = player.isFlashing ? '#ff0000' : '#ff4444';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, -radius * 0.5, radius * 0.6, Math.PI * 0.9, Math.PI * 0.1);
            ctx.stroke();
            
            ctx.fillStyle = player.isFlashing ? '#ffff00' : '#ffd700';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ÂΩ±', 0, -radius * 0.65);
            
            ctx.strokeStyle = player.isFlashing ? '#cc0000' : '#ff0000';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-radius * 0.8, radius * 0.3);
            ctx.bezierCurveTo(-radius * 1.2, radius * 0.8, -radius * 1.4, radius * 1.2, -radius * 1.6, radius * 1.4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(radius * 0.8, radius * 0.3);
            ctx.bezierCurveTo(radius * 1.2, radius * 0.8, radius * 1.4, radius * 1.2, radius * 1.6, radius * 1.4);
            ctx.stroke();
            
            ctx.strokeStyle = player.isFlashing ? '#ff4444' : '#3a3a5e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-radius * 0.3, 0);
            ctx.lineTo(-radius * 0.3, radius * 0.4);
            ctx.moveTo(radius * 0.3, 0);
            ctx.lineTo(radius * 0.3, radius * 0.4);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawKnife(knife) {
            ctx.save();
            ctx.translate(knife.x, knife.y);
            ctx.rotate(knife.rotation);
            
            // Fake knives have red tint
            if (knife.isFake) {
                ctx.globalAlpha = 0.7;
            }
            
            ctx.fillStyle = knife.isFake ? 'rgba(255, 0, 0, 0.4)' : 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(-knife.length / 2 + 3, -knife.width / 2 + 3, knife.length, knife.width);
            
            ctx.fillStyle = knife.isFake ? '#5a2a2a' : '#3a2a1a';
            ctx.fillRect(knife.length / 2 - 14, -knife.width / 2, 14, knife.width);
            
            ctx.strokeStyle = knife.isFake ? '#4a1a1a' : '#2a1a0a';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(knife.length / 2 - 12 + i * 3, -knife.width / 2);
                ctx.lineTo(knife.length / 2 - 12 + i * 3, knife.width / 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = knife.isFake ? '#6a3a3a' : '#5a4a3a';
            ctx.beginPath();
            ctx.arc(knife.length / 2 - 2, 0, knife.width / 2 + 2, 0, Math.PI * 2);
            ctx.fill();
            
            const bladeGradient = ctx.createLinearGradient(-knife.length / 2, 0, knife.length / 2, 0);
            if (knife.isFake) {
                bladeGradient.addColorStop(0, '#c08080');
                bladeGradient.addColorStop(0.3, '#ff8080');
                bladeGradient.addColorStop(0.6, '#e08080');
                bladeGradient.addColorStop(1, '#a06060');
            } else {
                bladeGradient.addColorStop(0, '#c0c0c0');
                bladeGradient.addColorStop(0.3, '#ffffff');
                bladeGradient.addColorStop(0.6, '#e0e0e0');
                bladeGradient.addColorStop(1, '#a0a0a0');
            }
            ctx.fillStyle = bladeGradient;
            ctx.beginPath();
            ctx.moveTo(-knife.length / 2, 0);
            ctx.lineTo(knife.length / 2 - 14, -knife.width / 2);
            ctx.lineTo(knife.length / 2 - 14, knife.width / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = knife.isFake ? 'rgba(255, 200, 200, 0.7)' : 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.moveTo(-knife.length / 2 + 5, -1);
            ctx.lineTo(knife.length / 2 - 16, -knife.width / 2 + 2);
            ctx.lineTo(knife.length / 2 - 16, -knife.width / 2 + 4);
            ctx.lineTo(-knife.length / 2 + 5, 1);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        function checkCollisions() {
            let knivesDeflected = 0;
            let perfectHitThisFrame = false;
            
            for (let i = knives.length - 1; i >= 0; i--) {
                const knife = knives[i];
                let deflected = false;
                
                for (const trail of bladeTrails) {
                    if (trail.points.length < 2) continue;
                    
                    for (let j = 0; j < trail.points.length - 1; j++) {
                        const p1 = trail.points[j];
                        const p2 = trail.points[j + 1];
                        
                        if (lineKnifeCollision(p1, p2, knife)) {
                            if (knife.isFake) {
                                // Fake knife penalty
                                gameState.combo = 0;
                                gameState.score = Math.max(0, gameState.score - 20);
                                showText('FAKE!', player.x, player.y - 100, '#ff0000');
                                playMissSound();
                            } else {
                                knives.splice(i, 1);
                                
                                // Check for perfect hit (close call)
                                const distToPlayer = Math.hypot(knife.x - player.x, knife.y - player.y);
                                const isPerfect = distToPlayer < player.radius + 80;
                                
                                if (isPerfect) {
                                    gameState.score += Math.floor(20 * gameState.riskMultiplier);
                                    gameState.perfectHits++;
                                    gameState.totalPerfectHits++;
                                    perfectHitThisFrame = true;
                                    showPerfectHit();
                                    playPerfectSound();
                                    
                                    // Trigger slow motion
                                    gameState.timeScale = 0.3;
                                    gameState.slowMoTimer = 200;
                                    document.getElementById('slowMoIndicator').classList.add('active');
                                } else {
                                    gameState.score += Math.floor(10 * gameState.riskMultiplier);
                                    playHitSound();
                                }
                                
                                knivesDeflected++;
                                
                                // Check risk bonus
                                if (distToPlayer < player.radius + 60) {
                                    gameState.riskMultiplier = Math.min(3, gameState.riskMultiplier + 0.2);
                                    gameState.closeCallTimer = 2000;
                                    showRiskBonus();
                                }
                            }
                            deflected = true;
                            
                            // Particles based on blade effect
                            const blade = blades[currentBlade];
                            for (let k = 0; k < 25; k++) {
                                particles.push(new Particle(knife.x, knife.y, blade.color, 'spark'));
                            }
                            
                            document.getElementById('score').classList.add('pop');
                            setTimeout(() => document.getElementById('score').classList.remove('pop'), 300);
                            
                            break;
                        }
                    }
                    if (deflected) break;
                }
            }
            
            if (knivesDeflected > 0) {
                gameState.combo += knivesDeflected;
                gameState.comboTimer = 2000;
                
                if (gameState.combo > gameState.maxCombo) {
                    gameState.maxCombo = gameState.combo;
                }
                
                if (gameState.combo >= 10 && gameState.combo % 10 === 0) {
                    showCombo();
                    playComboSound();
                }
                
                updateMultiplier();
            }
            
            // Check danger zone
            let inDanger = false;
            knives.forEach(knife => {
                if (!knife.isFake) {
                    const distToPlayer = Math.hypot(knife.x - player.x, knife.y - player.y);
                    if (distToPlayer < player.radius + 100) {
                        inDanger = true;
                    }
                }
            });
            
            if (inDanger) {
                document.getElementById('warningZone').classList.add('danger');
            } else {
                document.getElementById('warningZone').classList.remove('danger');
            }
            
            for (let i = knives.length - 1; i >= 0; i--) {
                const knife = knives[i];
                if (knife.isFake) continue;
                
                const dist = Math.hypot(knife.x - player.x, knife.y - player.y);
                
                if (dist < 25 + player.radius) {
                    knives.splice(i, 1);
                    takeDamage();
                }
            }
            
            updateUI();
        }

        function lineKnifeCollision(p1, p2, knife) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const dot = ((knife.x - p1.x) * dx + (knife.y - p1.y) * dy) / (len * len);
            
            const closestX = p1.x + dot * dx;
            const closestY = p1.y + dot * dy;
            
            const onSegment = dot >= 0 && dot <= 1;
            if (!onSegment) return false;
            
            const dist = Math.hypot(knife.x - closestX, knife.y - closestY);
            return dist < 28;
        }

        function takeDamage() {
            gameState.health--;
            gameState.combo = 0;
            gameState.riskMultiplier = 1;
            player.isFlashing = true;
            player.flashTimer = 0;
            updateMultiplier();
            
            const lifeIcons = document.querySelectorAll('.life-icon');
            if (lifeIcons[gameState.health]) {
                lifeIcons[gameState.health].classList.add('lost');
            }
            
            for (let k = 0; k < 20; k++) {
                particles.push(new Particle(player.x, player.y, '#ff0000', 'blood'));
            }
            
            // Screen shake
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 100);
            
            playLoseLifeSound();
            
            if (gameState.health <= 0) {
                gameOver();
            }
        }

        function showCombo() {
            const comboEl = document.getElementById('comboDisplay');
            comboEl.textContent = `${gameState.combo} COMBO!`;
            comboEl.classList.add('show');
            setTimeout(() => comboEl.classList.remove('show'), 800);
        }

        function showPerfectHit() {
            const perfectEl = document.getElementById('perfectHit');
            perfectEl.classList.add('show');
            setTimeout(() => perfectEl.classList.remove('show'), 600);
        }

        function showRiskBonus() {
            const riskEl = document.getElementById('riskBonus');
            riskEl.textContent = `RISK x${gameState.riskMultiplier.toFixed(1)}!`;
            riskEl.classList.add('show');
            setTimeout(() => riskEl.classList.remove('show'), 1000);
        }

        function updateMultiplier() {
            const mult = 1 + (gameState.combo * 0.1) * gameState.riskMultiplier;
            const multEl = document.getElementById('multiplier');
            multEl.textContent = `x${mult.toFixed(1)}`;
            multEl.classList.add('show');
        }

        function showText(text, x, y, color) {
            // Simple floating text (can be enhanced with DOM elements)
            console.log(text);
        }

        function checkAchievements() {
            // Check for blade unlocks
            Object.keys(blades).forEach(key => {
                const blade = blades[key];
                if (blade.unlocked || gameState.achievementsShown.has(key)) return;
                
                let unlocked = false;
                
                if (blade.requiredPerfect && gameState.totalPerfectHits >= blade.requiredPerfect) unlocked = true;
                if (blade.requiredCombo && gameState.maxComboEver >= blade.requiredCombo) unlocked = true;
                if (blade.requiredScore && gameState.maxScore >= blade.requiredScore) unlocked = true;
                if (blade.requiredTime && gameState.maxSurvivalTime >= blade.requiredTime) unlocked = true;
                if (blade.requiredHardcore && gameState.hardcoreWins > 0) unlocked = true;
                
                if (unlocked) {
                    blade.unlocked = true;
                    localStorage.setItem(`blade_${key}`, 'true');
                    showAchievement(`${blade.icon} ${blade.name} BLADE UNLOCKED!`);
                    gameState.achievementsShown.add(key);
                }
            });
        }

        function showAchievement(text) {
            const popup = document.getElementById('achievementPopup');
            popup.textContent = text;
            popup.classList.add('show');
            playPerfectSound();
            setTimeout(() => popup.classList.remove('show'), 3000);
        }

        function gameOver() {
            gameState.isGameOver = true;
            
            // Save high score
            const currentHS = parseInt(gameState.highScore[gameState.difficulty]) || 0;
            if (gameState.score > currentHS) {
                gameState.highScore[gameState.difficulty] = gameState.score;
                localStorage.setItem(`hs_${gameState.difficulty}`, gameState.score);
            }
            
            // Save global stats
            if (gameState.score > gameState.maxScore) {
                gameState.maxScore = gameState.score;
                localStorage.setItem('maxScore', gameState.maxScore);
            }
            
            if (gameState.maxCombo > gameState.maxComboEver) {
                gameState.maxComboEver = gameState.maxCombo;
                localStorage.setItem('maxCombo', gameState.maxComboEver);
            }
            
            if (gameState.survivalTime > gameState.maxSurvivalTime) {
                gameState.maxSurvivalTime = Math.floor(gameState.survivalTime);
                localStorage.setItem('maxSurvivalTime', gameState.maxSurvivalTime);
            }
            
            if (gameState.difficulty === 'hardcore' && gameState.survivalTime >= 60) {
                gameState.hardcoreWins++;
                localStorage.setItem('hardcoreWins', gameState.hardcoreWins);
            }
            
            localStorage.setItem('totalPerfectHits', gameState.totalPerfectHits);
            
            // Check achievements
            checkAchievements();
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('highScore').textContent = gameState.highScore[gameState.difficulty];
            document.getElementById('maxCombo').textContent = gameState.maxCombo;
            document.getElementById('perfectHits').textContent = gameState.perfectHits;
            document.getElementById('gameOver').classList.add('show');
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            
            const minutes = Math.floor(gameState.survivalTime / 60);
            const seconds = Math.floor(gameState.survivalTime % 60);
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Apply time scale (slow motion)
            deltaTime *= gameState.timeScale;
            
            drawBackground();
            updateBackground(deltaTime);
            
            if (gameState.gameStarted && !gameState.isGameOver) {
                player.x = canvas.width / 2;
                player.y = canvas.height / 2;
                player.pulsePhase += deltaTime * 0.003;
                player.rotation += deltaTime * 0.0005;
                player.breathePhase += deltaTime * 0.002;
                
                gameState.survivalTime += deltaTime / 1000;
                
                if (timestamp - gameState.lastSpawn > gameState.knifeSpawnRate / gameState.timeScale) {
                    spawnKnife();
                    gameState.lastSpawn = timestamp;
                }
                
                // Difficulty scaling every 10 seconds
                gameState.difficultyTimer += deltaTime;
                if (gameState.difficultyTimer > 10000) {
                    gameState.difficultyTimer = 0;
                    const settings = difficultySettings[gameState.difficulty];
                    gameState.knifeSpeed += settings.speedIncrease;
                    gameState.knifeSpawnRate = Math.max(250, gameState.knifeSpawnRate - settings.spawnDecrease);
                }
                
                // Update slow motion
                if (gameState.slowMoTimer > 0) {
                    gameState.slowMoTimer -= deltaTime * gameState.timeScale;
                    if (gameState.slowMoTimer <= 0) {
                        gameState.timeScale = 1;
                        document.getElementById('slowMoIndicator').classList.remove('active');
                    }
                }
                
                // Update combo timer
                if (gameState.comboTimer > 0) {
                    gameState.comboTimer -= deltaTime;
                    if (gameState.comboTimer <= 0) {
                        gameState.combo = 0;
                        updateMultiplier();
                        document.getElementById('multiplier').classList.remove('show');
                    }
                }
                
                // Update risk multiplier
                if (gameState.closeCallTimer > 0) {
                    gameState.closeCallTimer -= deltaTime;
                } else {
                    gameState.riskMultiplier = Math.max(1, gameState.riskMultiplier - 0.01);
                }
                
                for (let i = knives.length - 1; i >= 0; i--) {
                    const knife = knives[i];
                    knife.x += knife.vx;
                    knife.y += knife.vy;
                    knife.rotation += 0.18;
                    
                    if (knife.x < -100 || knife.x > canvas.width + 100 ||
                        knife.y < -100 || knife.y > canvas.height + 100) {
                        knives.splice(i, 1);
                    }
                }
                
                for (let i = bladeTrails.length - 1; i >= 0; i--) {
                    const trail = bladeTrails[i];
                    trail.lifetime += deltaTime;
                    trail.alpha = Math.max(0, 1 - trail.lifetime / 350);
                    
                    if (trail.alpha <= 0) {
                        bladeTrails.splice(i, 1);
                    }
                }
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    if (particles[i].alpha <= 0) {
                        particles.splice(i, 1);
                    }
                }
                
                checkCollisions();
                
                if (player.isFlashing) {
                    player.flashTimer += deltaTime;
                    if (player.flashTimer > 700) {
                        player.isFlashing = false;
                    }
                }
            }
            
            particles.forEach(p => p.draw());
            
            knives.forEach(knife => {
                ctx.save();
                ctx.globalAlpha = 0.3;
                for (let i = 1; i <= 3; i++) {
                    const trailKnife = {
                        x: knife.x - knife.vx * i * 3,
                        y: knife.y - knife.vy * i * 3,
                        rotation: knife.rotation - 0.18 * i,
                        length: knife.length,
                        width: knife.width,
                        isFake: knife.isFake
                    };
                    drawKnife(trailKnife);
                }
                ctx.restore();
                
                drawKnife(knife);
            });
            
            const flashCount = Math.floor(player.flashTimer / 100);
            const showPlayer = !player.isFlashing || flashCount % 2 === 0;
            
            if (showPlayer) {
                drawNinja(player.x, player.y, player.radius, player.rotation, player.breathePhase);
            }
            
            bladeTrails.forEach(trail => {
                if (trail.points.length < 2) return;
                
                const bladeColor = blades[currentBlade].color;
                const r = parseInt(bladeColor.slice(1, 3), 16);
                const g = parseInt(bladeColor.slice(3, 5), 16);
                const b = parseInt(bladeColor.slice(5, 7), 16);
                
                ctx.save();
                ctx.globalAlpha = trail.alpha;
                
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${trail.alpha * 0.4})`;
                ctx.lineWidth = 30;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 30;
                ctx.shadowColor = bladeColor;
                
                ctx.beginPath();
                ctx.moveTo(trail.points[0].x, trail.points[0].y);
                for (let i = 1; i < trail.points.length; i++) {
                    ctx.lineTo(trail.points[i].x, trail.points[i].y);
                }
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${trail.alpha * 0.7})`;
                ctx.lineWidth = 18;
                ctx.shadowBlur = 25;
                
                ctx.beginPath();
                ctx.moveTo(trail.points[0].x, trail.points[0].y);
                for (let i = 1; i < trail.points.length; i++) {
                    ctx.lineTo(trail.points[i].x, trail.points[i].y);
                }
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${trail.alpha})`;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ffffff';
                
                ctx.beginPath();
                ctx.moveTo(trail.points[0].x, trail.points[0].y);
                for (let i = 1; i < trail.points.length; i++) {
                    ctx.lineTo(trail.points[i].x, trail.points[i].y);
                }
                ctx.stroke();
                
                ctx.restore();
            });
            
            requestAnimationFrame(gameLoop);
        }

        // UI Event Handlers
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.getAttribute('data-mode');
                const settings = difficultySettings[mode];
                
                gameState.difficulty = mode;
                gameState.knifeSpeed = settings.knifeSpeed;
                gameState.knifeSpawnRate = settings.spawnRate;
                
                document.getElementById('startScreen').classList.remove('show');
                gameState.gameStarted = true;
                gameState.lastSpawn = performance.now();
                gameState.survivalTime = 0;
            });
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            const settings = difficultySettings[gameState.difficulty];
            
            gameState.score = 0;
            gameState.health = 3;
            gameState.isGameOver = false;
            gameState.gameStarted = true;
            gameState.knifeSpeed = settings.knifeSpeed;
            gameState.knifeSpawnRate = settings.spawnRate;
            gameState.lastSpawn = performance.now();
            gameState.difficultyTimer = 0;
            gameState.combo = 0;
            gameState.comboTimer = 0;
            gameState.maxCombo = 0;
            gameState.perfectHits = 0;
            gameState.timeScale = 1;
            gameState.slowMoTimer = 0;
            gameState.riskMultiplier = 1;
            gameState.closeCallTimer = 0;
            gameState.survivalTime = 0;
            
            knives.length = 0;
            bladeTrails.length = 0;
            particles.length = 0;
            player.isFlashing = false;
            player.flashTimer = 0;
            
            const lifeIcons = document.querySelectorAll('.life-icon');
            lifeIcons.forEach(icon => icon.classList.remove('lost'));
            
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('multiplier').classList.remove('show');
            updateUI();
        });

        document.getElementById('menuBtn').addEventListener('click', () => {
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('startScreen').classList.add('show');
            gameState.gameStarted = false;
            gameState.isGameOver = false;
            gameState.score = 0;
            gameState.health = 3;
            
            knives.length = 0;
            bladeTrails.length = 0;
            particles.length = 0;
            
            const lifeIcons = document.querySelectorAll('.life-icon');
            lifeIcons.forEach(icon => icon.classList.remove('lost'));
        });

        document.getElementById('bladesBtn').addEventListener('click', () => {
            document.getElementById('startScreen').classList.remove('show');
            document.getElementById('upgradeScreen').classList.add('show');
            renderBladeSelection();
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            document.getElementById('upgradeScreen').classList.remove('show');
            document.getElementById('startScreen').classList.add('show');
        });

        document.getElementById('muteBtn').addEventListener('click', () => {
            isMuted = !isMuted;
            document.getElementById('muteBtn').textContent = isMuted ? 'üîá' : 'üîä';
        });

        function renderBladeSelection() {
            const container = document.getElementById('bladeSelection');
            container.innerHTML = '';
            
            Object.keys(blades).forEach(key => {
                const blade = blades[key];
                const card = document.createElement('div');
                card.className = 'blade-card';
                if (blade.unlocked) card.classList.add('unlocked');
                else card.classList.add('locked');
                if (key === currentBlade) card.classList.add('selected');
                
                card.innerHTML = `
                    <div class="blade-icon">${blade.icon}</div>
                    <div class="blade-name">${blade.name}</div>
                    <div class="blade-requirement">${blade.unlocked ? 'UNLOCKED' : blade.requirement}</div>
                `;
                
                if (blade.unlocked) {
                    card.addEventListener('click', () => {
                        currentBlade = key;
                        localStorage.setItem('selectedBlade', key);
                        renderBladeSelection();
                    });
                }
                
                container.appendChild(card);
            });
        }

        // Initialize
        initBackground();
        updateUI();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
